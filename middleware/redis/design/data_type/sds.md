---
date: 2021-10-25
---



## c语言字符串

- 字符串的两种写法如下所示

```c
// 字节数组
char name[6] = {'R', 'e', 'd', 'i', 's','\0'};  
// 字符串
char name[] = "Redis";
```

- 字符串的常见操作

  | 序号 | 操作 | 函数(自造伪代码) | 函数              | 说明                    |
  | ---- | ---- | ---------------- | ----------------- | ----------------------- |
  | 1    | 复制 | copy(s1, s2)     | strcpy(s1,s2)     | 复制字符串 s2到s1       |
  | 2    | 连接 | append(s1, s2)   | strcat(s1,s2)     | 连接字符串s2到s1        |
  | 3    | 统计 | len(s1)          | strlen(s1)        | 返回字符串的长度        |
  | 4    | 裁剪 | trim(s1,s2)      |                   | 移除字符串s1中出现的s2  |
  | 5    | 对比 | compare(s1,s2)   | strcasecmp(s1,s2) | 对比字符串s1,s2是否相同 |
  | 6    | 打印 |                  | printf("%s",s1)   | 打印字符串s1            |

- 上面简单列举了c字符串的一些信息，c字符串的还有如下的特点。(注一)
  1. c字符串没有存储字符串的长度信息，所以做字符串长度统计时，需要遍历整个字符串，时间复杂度为O(n)
  2. c字符串没有存储字符串的长度信息，所以做字符串拼接时，需要手动判断并申请新的缓存区，防止缓冲区溢出
  3. c字符串与字符数组的关系，使得c字符串修改时(增长或者缩短)，都需要对字符串数组进行一次内存重分配操作。
     1. 增长时，需要申请额外的内存，否则会产生缓存区溢出。
     2. 缩短时，需要释放不再使用的空间，否则会产生内存泄漏。
  4. 二进制安全问题，由于不是主要研究c语言，此条不再描述。

基于以上c字符串的信息，我们需要构造redis中使用的字符串结构。

## Redis字符串

- 字符串结构体

```c
 // 首字母大写是个人写go的习惯
struct Sdshdr {
  int  Len;      // 记录此字符串已使用的字节数量
  int  Free;     // 记录此字符串空闲的字符串数量
  char Buf[];    // 字节数组，保存字符串    char name[6] = {'R', 'e', 'd', 'i', 's','\0'};  注二
}
```

- 结构体对应的函数(这里伪代码仅为理解下面的分析)

```go
// 统计字符串长度
func (s *Sdshdr) Len() int {
  return s.Len
}

// 在字符串的末尾追加s2
func (s *Sdshdr) Append(s2 string){
  s2Len = strlen(s2)
  if s.Free < strlen(s2){
    // 分配空间 隐藏分配策略
  }
  s.Len  += s2Len
  s.Free -= s2Len
  s.Buf  = Append(s1,s2)
}

// 字符串裁剪
func (s *Sdshdr) Rtrim(s2 string){
  ret = rtrim(s.Bug,s2)
  if ret {
      s.Len  -= s2Len
      s.Free += s2Len
  }
}

// 真实释放内存
func (s *Sdshdr) RealFree(){
}
```

- 结构体设计分析(对应前面的注一)
  1. 通过结构体与伪代码Len()，可以看出，需要获取字符串长度时，不论字符串长度，均可以获取结构体的Len的值，时间复杂度为O(1)
  2. 通过结构体和伪代码Append()，可以看出，当需要存储额外的字符串时，我们动态申请内存，以防止缓存区溢出。
  3. 通过结构体和伪代码Rtrim()，可以看出，当需要裁剪字符串时，并未真实的释放内存，仅标记了已使用空间和未使用空间，可以在后续字符串增加时，直接使用空闲空间，减少内存重分配次数，这是redis提供的惰性分配策略。如果需要真实释放内存时，redis提供的有有释放内存的函数。
  4. 结构体中注二部分，依然采用c字符串的\n结尾，这样可以复用c语言类库的一些函数。
- 补充说明空间分配策略
  - 前面说过，如果执行append时，如果没有为字符数组的空间进行扩容(内存重分配)，就会缓冲区溢出，如果频繁的申请内存，也可能会频繁的执行系统调用，一般程序字符串修改的可能性比较小，也不太频繁，偶尔进行能存再分配可以接受。
  - Redis的使用场景，可能会频繁的修改字符串，如果每次改变字符串的长度都进行内存重分配，很可能会影响性能。
  - 空间预分配，一次申请足够的空间，如果修改SDS之后，SDS的Len小于1MB，就会为Free分配Len等同的空间。如果Len大于等于1M，将为Free申请1M空间。（可能有小伙伴会问为什么是翻倍，以及以1M为界限，你也可以0.5倍，2M为界限，这只是一种策略。可能Redis做过数据统计，这个策略更通用？避免了空间浪费也避免了频繁申请内存。如果有小伙伴知道答案，欢迎与我分享。）
  - 惰性空间释放与真实释放未使用空间，也可以做到空间复用，以及不会内存泄漏。

个人理解：SDS把语言的定长字节数组，变为了变长字节数组。(当然不仅限于此)

## c字符串与Redis字符串(SDS)总结

| c字符串                                | SDS                                                      |
| -------------------------------------- | -------------------------------------------------------- |
| 获取字符串长度 时间复杂度O(n)          | 获取字符串长度 时间复杂度O(1)、支持Redis的Strlen频繁使用 |
| API不安全，可能会造成缓冲区溢出        | API安全，不会造成缓冲区溢出                              |
| 修改字符串N次必然需要执行N次内存重分配 | 修改字符串长度N次，最多需要执行N次内存重分配             |
| 只能保存文本数据                       | 可以保存文本或者二进制数据(图片，音频等)                 |
| 可以使用所有<string.h>库函数           | 可以使用一部分<string.h>库函数                           |

## SDS API

- redis既然构建了一个新的结构，为其提供一些方便操作的API，也就顺利成章。这里只列举几个简单的，更多的请看书。

| 函数     | 作用                   | 时间复杂度           |
| -------- | ---------------------- | -------------------- |
| sdsnew   | 根据C字符串创建一个SDS | O(n)，N为c字符串长度 |
| sdsempty | 创建空SDS              | O(1)                 |
| sdsfree  | 释放SDS                | O(n)，N为SDS长度     |
| sdslen   | 返回已使用空间         | O(1)                 |
| sdsavail | 返回未使用空间         | O(1)                 |

