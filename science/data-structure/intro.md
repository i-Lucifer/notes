---
title: 数据结构综合
---

[[TOC]]
[TOC]

## 数据结构

### 评定标准

- 时间复杂度和空间复杂度的取舍，多数情况下，时间复杂度更重要，比如数据库缓存，就是空间换时间

#### 时间复杂度

- 常数、对数、线性、指数

#### 空间复杂度

- 常量、线性、二维空间、递归空间

### 常见结构

物理结构(存储结构)

- 顺序存储结构-数组
- 链式存储结构-链表

逻辑结构

- 线性结构
  - 顺序表、栈、队列
- 非线性结构
  - 图、树(二叉树、N叉树) (小知识，逻辑结构一般都可以用物理结构中的数组或者链表实现)

衍生结构(非书上分类)

- 跳跃链表
- 哈希链表 (缓存淘汰算法LRU)
- 位图

### 对比

- 基于以下两种数据结构，来看一下B+树
  - 非叶子节点，向下层查找数据，属于随机访问，层数不变过高，要稳定读盘次数
  - 叶子节点，一块比较大的数据上，属于顺序读取
  - 叶子节点，多块数据之间，由指针指向磁盘位置，属于随机读取(寻址)
  - 总体上，叶子节点属于顺序读取(或者批量读取)
- 特点对比

| 结构 | 物理结构 | 查找 | 更新 | 插入 | 删除 | 优点           | 缺点                         |
| ---- | -------- | ---- | ---- | ---- | ---- | -------------- | ---------------------------- |
| 数组 | 顺序存储 | O(1) | O(1) | O(n) | O(n) | 随机访问高效   | 插入删除要移动数据，影响效率 |
| 链表 | 随机存储 | O(n) | O(1) | O(1) | O(1) | 灵活插入和删除 | 查找数据麻烦                 |

- 特点对比续

| 结构 | 特点                        | 适合场景                          | 直接应用                | 相关算法          |
| ---- | --------------------------- | --------------------------------- | ----------------------- | ----------------- |
| 数组 | 顺序存储 只记录首地址和长度 | 读多写少                          | 语言的string与[]byte    | 二分查找 O log(n) |
| 链表 | 不考虑扩容，利用零碎内存    | 写多读少</br>双端读写，低深度访问 | redis的list go的channel |                   |

### 数组

#### 数组结构

- 结构示例 位 bit
  - 申请四个字节，来存储MQTT，比如golang的[]byte


| 内存地址\位索引 | 十进制 | 十六进制 | 代表字符 | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| --------------- | ------ | -------- | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| ox 01           | 77     | 4d       | M        | 0    | 1    | 0    | 0    | 1    | 1    | 0    | 1    |
| ox 02           | 81     | 51       | Q        | 0    | 1    | 0    | 1    | 0    | 0    | 0    | 1    |
| ox 03           | 84     | 54       | T        | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 0    |
| ox 04           | 84     | 54       | T        | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 0    |

- 结构示例 字节 byte
  - MQTT，占用四个字节，中国你好，占用8个字节，比如golang的string，底层本质上还是字节数组


| 内存     | ox00 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | ox08 | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数组索引 | 0    | 1    | 2    | 3    |      |      |      |      | 0    |      | 1    |      | 2    |      | 3    |      |
| 存储值   | M    | Q    | T    | T    | 空   | 闲   | 内   | 存   | 中   |      | 国   |      | 你   |      | 好   |      |

#### 数组特征

- 数据连续 在物理上<font color="red">顺序存储</font>
- 可以通过索引访问
- 数组有固定长度，如果扩容，则需要重新申请内存，并将数据复制过去

#### 数组增删改查

| 操作        | 说明                                                         | 复杂度 |
| ----------- | ------------------------------------------------------------ | ------ |
| 读          | 可以通过索引读取，俗称<font color="red">随机读取</font>      | 1      |
| 更          | 可以通过索引直接更新                                         | 1      |
| 插入 尾部   | 最简单，直接将元素插入到最尾部的空闲位置                     | 1      |
| 插入 中间   | 先挪移，再插入                                               | n      |
| 插入 超范围 | 先扩容，再插入，扩容=申请内存+复制旧数据</br>小容量采取翻倍扩容，大容量可以1.25倍扩容(golang的切片) | n      |
| 删          | 与插入相反                                                   | n      |

### 链表

#### 链表结构

- 用链表表示数据

| 内存地址 | ox00 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | ox08 | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 存储值   | ox08 | ox24 |      |      |      |      |      |      | NULL | 你   |      | 好   |      |      |      |      |
| 内存地址 | ox16 | 1    | 2    | 3    | 4    | 5    | 6    | 7    | ox24 | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| 存储值   |      |      |      |      |      |      |      |      | M    | Q    | T    | T    |      |      |      |      |

- 用代码表示

```go
type Node struct{
  Next *Node  // 指针在数据上面，对应内存里，推测指针应该在前面
	Data string
}

func New(){
  head := new(Node)  // 得到地址0x00
  First := new(Node) // 得到地址0x08
 	head.Next = First  // 将0x08记录到内存中

  head.Data = "MQTT" // 为节点赋值，注意，1-7的地址可能不够，所以这里记录的可能是指针0x24
  First.Data = "你好" // 如果空间够，直接记录值，个人更倾向于认为记录指针
}
```

#### 链表特征

- 数据不连续 在物理上<font color="red">随机存储</font>
- 只能通过指针依次访问，不能通过索引访问
- 可以无限扩容

#### 链表分类

| 分类         | 场景                            |
| ------------ | ------------------------------- |
| 单向链表     |                                 |
| 双向链表     |                                 |
| 单项循环链表 |                                 |
| 双向循环链表 | mysql的redo_log golang的channel |

#### 链表增删改查

没有固定长度，不需要考虑超范围插入

| 操作      | 说明                                                         | 复杂度 |
| --------- | ------------------------------------------------------------ | ------ |
| 读        | 查找数据，只能从头节点依次向后查，<font color="red">只能顺序读取</font> | n      |
| 更        | 先查找，后更新，查找O(n)，更新O(1)                           | 1      |
| 插入 尾部 | 尾部指针，指向数据                                           | 1      |
| 插入 头部 | 新数据指向第一个节点，head指向新数据                         | 1      |
| 插入 中间 | 新数据指向下一个节点，上一个节点指向新数据，可能需要查找的O(n) | 1      |
| 删        | 插入的反操作                                                 | 1      |
